🚨 PROJETO DETALHADO: Modelagem de Inundações Agrícolas no GAMA
📁 1. ESTRUTURA COMPLETA DE ARQUIVOS
text
projeto_inundacao_rs/
│
├── models/
│   ├── MAIN.gaml                    → Arquivo principal do modelo
│   ├── HIDROLOGIA.gaml              → Funções de cálculo hídrico
│   ├── DANOS_AGRICOLAS.gaml         → Funções de perdas agrícolas
│   └── VISUALIZACAO.gaml            → Configurações de visualização
│
├── data/
│   ├── ENTRADA/
│   │   ├── DEM/
│   │   │   ├── dem.tif              → Modelo Digital de Elevação
│   │   │   └── declividade.tif      → Calculado a partir do DEM
│   │   │
│   │   ├── SOLO/
│   │   │   ├── penetrometro.csv     → Dados de resistência do solo
│   │   │   ├── tipos_solo.shp       → Mapa de tipos de solo
│   │   │   └── capacidade_infiltracao.tif
│   │   │
│   │   ├── HIDROLOGIA/
│   │   │   ├── rios.shp             → Rede hidrográfica
│   │   │   ├── chuva.csv            → Dados de precipitação
│   │   │   └── vazao_rios.csv       → Dados de vazão dos rios
│   │   │
│   │   └── USO_SOLO/
│   │       ├── culturas.shp         → Mapa de culturas agrícolas
│   │       ├── terraceamento.shp    → Áreas com terraceamento
│   │       └── valor_hectare.csv    → Valor econômico por cultura
│   │
│   └── SAIDA/
│       ├── CSV/
│       │   ├── inundacao_por_celula.csv
│       │   ├── perdas_agricolas.csv
│       │   └── evolucao_temporal.csv
│       │
│       ├── SHAPES/
│       │   ├── areas_inundadas.shp
│       │   └── danos_culturas.shp
│       │
│       └── IMAGENS/
│           ├── mapas_inundacao/
│           └── graficos_evolucao/
│
├── scripts/
│   ├── pre_processamento.py         → Scripts para preparar dados
│   └── pos_processamento.R          → Análise dos resultados
│
└── documentation/
    ├── parametros_modelo.md         → Lista de todos os parâmetros
    └── guia_instalacao.md           → Como configurar o projeto
🧮 2. FÓRMULAS E CÁLCULOS ESSENCIAIS
A. Cálculo de Infiltração do Solo
Fórmula de Philip modificada:
python
Infiltração [mm/h] = (0.5 * S * t^(-0.5)) + (K * t)

Onde:
S = Sorptividade (mm/h⁰·⁵) = 125 * (Resistência^0.3)
K = Condutividade hidráulica (mm/h) = 85 * (Resistência^-0.4)
t = Tempo (horas)
Resistência = Dados do penetrômetro (kPa)
B. Escoamento Superficial
Método SCS-CN adaptado:
python
P_excesso = (P - 0.2 * S)^2 / (P + 0.8 * S)

Onde:
P = Precipitação total (mm)
S = Retenção potencial máxima (mm) = 25400/CN - 254
CN = Número de curva (ajustado pela resistência do solo)
C. Propagação do Fluxo
Método D8 com terraceamento:
python
Direção_fluxo = 
  SE terraceamento = true: 
    direção_terraço
  SENÃO:
    direção_maior_declive(DEM)

Vazão_saída = profundidade_água * declividade * coeficiente_rugosidade
D. Cálculo de Danos Agrícolas
python
Perda_por_cultura = 
  Área_inundada * 
  Profundidade_água * 
  Fator_sensibilidade_cultura * 
  Valor_hectare_cultura *
  Duração_inundação
📊 3. ESTRUTURA DOS ARQUIVOS CSV
A. penetrometro.csv
csv
id,latitude,longitude,resistencia_kpa,profundidade_cm,tipo_solo,umidade_percent
1,-30.123,-51.456,1250,18,argiloso,25.3
2,-30.124,-51.457,850,22,arenoso,18.7
3,-30.125,-51.458,1500,15,argiloso,30.1
B. chuva.csv
csv
data_hora,precipitacao_mm,duracao_min,intensidade_mmh
2024-05-01 14:00:00,0.0,5,0.0
2024-05-01 14:05:00,2.1,5,25.2
2024-05-01 14:10:00,5.8,5,69.6
2024-05-01 14:15:00,12.4,5,148.8
C. valor_hectare.csv
csv
cultura,valor_rs_ha,estadio_crescimento,fator_sensibilidade
soja,8500.00,vegetativo,0.85
milho,7200.00,florescimento,0.92
arroz,6800.00,maturacao,0.45
trigo,6100.00,emergencia,0.78
🎯 4. SEQUÊNCIA DE EXECUÇÃO DETALHADA
Fase 1: Pré-processamento (Python/QGIS)
python
# 1. Processar DEM → gerar declividade, direção de fluxo
# 2. Interpolar dados do penetrômetro → mapa de resistência
# 3. Calcular CN (Número de Curva) para cada célula
# 4. Preparar série temporal de chuva
# 5. Processar dados de terraceamento
Fase 2: Implementação no GAMA
Passo 2.1: Carregar dados espaciais
gaml
// Carregar DEM
global dem_data <- gis_file("../data/ENTRADA/DEM/dem.tif");

// Carregar mapa de culturas
global culturas_data <- gis_file("../data/ENTRADA/USO_SOLO/culturas.shp");

// Carregar dados do penetrômetro
global dados_penetrometro <- read_csv("../data/ENTRADA/SOLO/penetrometro.csv");
Passo 2.2: Inicializar células do terreno
gaml
agent CelulaTerreno {
    // Atributos básicos
    float elevacao;
    float resistencia_solo;
    string tipo_cultura;
    float valor_hectare;
    bool terraceamento;
    
    // Variáveis dinâmicas
    float profundidade_agua <- 0.0;
    float agua_infiltrada <- 0.0;
    float escoamento_superficial <- 0.0;
    
    // Inicialização
    init {
        elevacao <- dem_value_at(location);
        resistencia_solo <- interpolate_penetrometer(location);
        tipo_cultura <- get_crop_type(location);
        valor_hectare <- get_crop_value(tipo_cultura);
        terraceamento <- has_terracing(location);
    }
}
Passo 2.3: Simulação hidrológica
gaml
reflex aplicar_chuva {
    ask CelulaTerreno {
        float precip_atual <- get_precipitation(current_time);
        float infiltracao <- calcular_infiltracao(precip_atual, resistencia_solo);
        float excesso <- calcular_excesso(precip_atual, infiltracao);
        
        agua_infiltrada <- agua_infiltrada + infiltracao;
        profundidade_agua <- profundidade_agua + excesso;
    }
}

reflex propagar_agua {
    ask CelulaTerreno where (profundidade_agua > 0.01) {
        list<CelulaTerreno> vizinhas <- self neighbors_at(10.0);
        list<CelulaTerreno> vizinhas_baixas <- 
            vizinhas where (each.elevacao < self.elevacao);
        
        if not empty(vizinhas_baixas) {
            float agua_propagada <- profundidade_agua * 0.7;
            distribuir_agua_vizinhas(vizinhas_baixas, agua_propagada);
            profundidade_agua <- profundidade_agua * 0.3;
        }
    }
}
Passo 2.4: Cálculo de danos
gaml
reflex calcular_danos {
    map<string, float> perdas_totais <- map([]);
    
    ask CelulaTerreno where (profundidade_agua > 0.3) {
        float perda_celula <- profundidade_agua * valor_hectare * 
                            get_sensitivity_factor(tipo_cultura);
        
        perdas_totais[tipo_cultura] <- perdas_totais[tipo_cultura] + perda_celula;
    }
    
    // Salvar resultados
    save perdas_totais to: "../data/SAIDA/CSV/perdas_agricolas.csv";
}
⚙️ 5. PARÂMETROS AJUSTÁVEIS DO MODELO
gaml
global params {
    // Parâmetros hidrológicos
    float coeficiente_infiltracao <- 0.85;
    float coeficiente_escoamento <- 0.75;
    float fator_terraceamento <- 0.6;
    
    // Parâmetros de simulação
    int duracao_simulacao <- 240; // minutos
    int intervalo_tempo <- 5; // minutos
    float tamanho_celula <- 
📈 6. SAÍDAS E ANÁLISES
Arquivos de Saída Gerados:
    1. inundacao_por_celula.csv: Profundidade de água em cada célula ao longo do tempo
    2. perdas_agricolas.csv: Perdas financeiras por tipo de cultura
    3. evolucao_temporal.csv: Evolução da inundação ao longo do tempo
    4. areas_inundadas.shp: Polígonos das áreas afetadas
Métricas de Análise:
    • Área total inundada (hectares)
    • Volume total de água escoado (m³)
    • Perdas financeiras totais (R$)
    • Tempo de concentração do escoamento
    • Eficiência do terraceamento na redução de danos
🚨 7. VALIDAÇÃO DO MODELO
Comparar com:
    1. Dados históricos de inundações na região
    2. Imagens de satélite pós-evento
    3. Relatos dos agricultores sobre áreas afetadas
    4. Dados de estações fluviométricas próximas
Métodos de validação:
    • Análise de correlação entre áreas simuladas e observadas
    • Cálculo de erro médio quadrático (RMSE)
    • Índice de Nash-Sutcliffe (NSE) para vazões
__________________________________________________________________-

🌧️ Variáveis de Chuva que você vai considerar:
1. Volume Total de Chuva (mm)
gaml
// Diferentes formas de calcular a chuva
global {
    // Método 1: Chuva constante (mm/h → mm acumulado)
    float intensidade_chuva_mmh <- 40.0; // mm/h
    float duracao_chuva_min <- 30.0;     // minutos
    float volume_chuva_mm <- intensidade_chuva_mmh * (duracao_chuva_min / 60.0);
    
    // Método 2: Série temporal de chuva (mais realista)
    list<map<string, float>> serie_temporal_chuva <- [
        ["tempo": 0, "precipitacao": 0.0],
        ["tempo": 5, "precipitacao": 2.1], 
        ["tempo": 10, "precipitacao": 5.8],
        ["tempo": 15, "precipitacao": 12.4],
        ["tempo": 20, "precipitacao": 25.6],
        ["tempo": 25, "precipitacao": 18.3],
        ["tempo": 30, "precipitacao": 9.7]
    ];
    
    // Método 3: Chuva de projeto (padrão)
    float[] chuvas_projeto <- [50, 80, 100, 150]; // mm em 24h
}
2. Transbordamento do Rio
gaml
// Variáveis do rio
agent Rio {
    geometry geometria;
    float cota_leito;      // altura do fundo do rio
    float cota_margem;     // altura das margens
    float vazao_atual;     // m³/s
    float vazao_maxima;    // capacidade máxima antes de transbordar
    
    // Calcular transbordamento
    bool esta_transbordando() {
        return vazao_atual > vazao_maxima;
    }
    
    // Volume de transbordamento
    float volume_transbordamento() {
        return max(0.0, vazao_atual - vazao_maxima) * 3600.0; // m³/h
    }
}

🔄 Como integrar no seu modelo GAMA:
Passo 1: Simular a Chuva + Rio Simultaneamente
gaml
reflex simular_evento_completo {
    // 1. Aplicar chuva na bacia
    float precip_atual <- get_precipitacao(tempo_atual);
    ask CelulaTerreno {
        aplicar_chuva(precip_atual);
    }
    
    // 2. Calcular contribuição para o rio
    float contribuicao_para_rio <- sum(CelulaTerreno collect each.escoamento_superficial);
    
    // 3. Atualizar vazão do rio
    ask Rio {
        vazao_atual <- vazao_atual + contribuicao_para_rio;
        
        // 4. Se transbordar, adicionar água nas células ribeirinhas
        if (esta_transbordando()) {
            float volume_extra <- volume_transbordamento();
            distribuir_transbordamento(volume_extra);
        }
    }
}
Passo 2: Cálculo do Volume Total Inundante
gaml
// Em cada célula do terreno
agent CelulaTerreno {
    float volume_chuva_direta;    // mm → m³
    float volume_transbordamento; // m³ do rio
    float volume_total_inundacao; // soma total
    
    // Atualizar volumes
    reflex calcular_volumes {
        // Volume da chuva direta (mm → m³)
        volume_chuva_direta <- precipitacao_acumulada * area_celula / 1000.0;
        
        // Volume total
        volume_total_inundacao <- volume_chuva_direta + volume_transbordamento;
        
        // Converter para profundidade (metros)
        profundidade_agua <- volume_total_inundacao / area_celula;
    }
}

📊 Tabela de Resultados que você vai gerar:
Cenários Combinados:
Chuva (mm)
Tempo (min)
Transbordamento
Área Inundada (ha)
Volume Total (m³)
50 mm
30 min
Não
5.2 ha
12,500 m³
50 mm
30 min
Sim
18.7 ha
45,800 m³
80 mm
45 min
Não
12.8 ha
28,900 m³
80 mm
45 min
Sim
35.4 ha
82,100 m³
100 mm
60 min
Sim
62.3 ha
148,700 m³
Código para gerar essa tabela:
gaml
global {
    map<string, map<string, float>> resultados_combinados;
    
    reflex gerar_tabela_resultados {
        foreach chuva in [50, 80, 100] {
            foreach tempo in [30, 45, 60] {
                foreach transborda in [true, false] {
                    // Simular cenário
                    simular_cenario(chuva, tempo, transborda);
                    
                    // Registrar resultados
                    string cenario <- chuva + "mm_" + tempo + "min_" + transborda;
                    resultados_combinados[cenario] <- [
                        "area_inundada": area_total_inundada,
                        "volume_total": volume_total_inundacao,
                        "profundidade_max": profundidade_maxima
                    ];
                }
            }
        }
        
        // Exportar para CSV
        save resultados_combinados to: "resultados_combinados.csv";
    }
}

🎯 Análise de Pontos Críticos:
1. Limiar de Transbordamento:
gaml
// Descobrir quando o rio começa a transbordar
float encontrar_limiar_transbordamento() {
    return resultados_combinados
        .where(each.value["transbordamento"] == true)
        .min(each.value["chuva_mm"]);
}
2. Efeito Combinado Chuva+Rio:
gaml
// Calcular o fator de ampliação do transbordamento
map<string, float> calcular_ampliacao() {
    map<string, float> ampliacao;
    
    foreach chuva in [50, 80, 100] {
        float area_sem_transbordo <- resultados_combinados[chuva + "mm_false"]["area_inundada"];
        float area_com_transbordo <- resultados_combinados[chuva + "mm_true"]["area_inundada"];
        
        ampliacao[chuva + "mm"] <- area_com_transbordo / area_sem_transbordo;
    }
    
    return ampliacao; // Ex: {"50mm": 3.6, "80mm": 2.8, "100mm": 2.4}
}

📋 Saída Prática para o Agricultor:
Relatório de Risco:
text
SUA PROPRIEDADE - ANÁLISE DE RISCO:

CHUVA MODERADA (50 mm em 30 min):
• Sem transbordamento: 5 ha alagados
• Com transbordamento: 19 ha alagados (3.6× MAIS!)

CHUVA FORTE (100 mm em 60 min):  
• Área crítica: 62 ha alagados
• Volume total: 150.000 m³ de água

RECOMENDAÇÃO: 
Reforçar margens do rio nos pontos X, Y, Z
____________________________________________________________
















O QUE SERÁ PRECISO FAZER EM PYTHON 


Arquivos Python necessários:
bash
projeto_rs/
├── pre_processamento.py
├── processar_dem.py
├── calcular_fluxo.py
└── gerar_entradas_gama.py
1. pre_processamento.py - Processamento inicial:
python
# -*- coding: utf-8 -*-
import geopandas as gpd
import rasterio
import numpy as np
import pandas as pd
from osgeo import gdal

def processar_dados_entrada():
    """Processa todos os dados de entrada para o GAMA"""
    
    # 1. Processar DEM → calcular declividade e direção de fluxo
    dem_path = "data/ENTRADA/DEM/dem.tif"
    calcular_declividade(dem_path)
    calcular_direcao_fluxo(dem_path)
    
    # 2. Processar dados do penetrômetro
    penetrometro_path = "data/ENTRADA/SOLO/penetrometro.csv"
    processar_penetrometro(penetrometro_path)
    
    # 3. Processar terraceamento
    terraceamento_path = "data/ENTRADA/USO_SOLO/terraceamento.shp"
    processar_terraceamento(terraceamento_path)
    
    # 4. Gerar arquivos de entrada para o GAMA
    gerar_arquivos_gama()
de
def calcular_declividade(dem_path):
    """Calcula declividade a partir do DEM"""
    with rasterio.open(dem_path) as src:
        dem = src.read(1)
        x_res, y_res = src.res
        dx, dy = np.gradient(dem, x_res, y_res)
        declividade = np.sqrt(dx**2 + dy**2)
        
        # Salvar declividade
        with rasterio.open('data/SAIDA/declividade.tif', 'w', **src.profile) as dst:
            dst.write(declividade, 1)

def processar_penetrometro(csv_path):
    """Interpola dados do penetrômetro para criar mapa de resistência"""
    df = pd.read_csv(csv_path)
    # Interpolação espacial (Kriging ou IDW)
    # Retorna raster com resistência do solo
    return resistencia_raster
2. gerar_entradas_gama.py - Criar arquivos para o GAMA:
python
def gerar_arquivos_gama():
    """Gera todos os arquivos CSV que o GAMA vai ler"""
    
    # 1. CSV de células do terreno
    celulas = []
    for x in range(n_cols):
        for y  in range(n_rows):
            celula = {
                'id': f"cell_{x}_{y}",
                'x': x * resolucao,
                'y': y * resolucao, 
                'elevacao': dem[y, x],
                'resistencia': resistencia[y, x],
                'terraço': terraceamento[y, x],
                'cultura': culturas[y, x]
            }
            celulas.append(celula)
    
    pd.DataFrame(celulas).to_csv('data/SAIDA/celulas_terreno.csv', index=False)
    
    # 2. CSV de chuva
    chuvas = [
        {'tempo_min': 0, 'precip_mm': 0},
        {'tempo_min': 5, 'precip_mm': 2.1},
        {'tempo_min': 10, 'precip_mm': 5.8},
        # ... mais dados de chuva
    ]
    pd.DataFrame(chuvas).to_csv('data/SAIDA/chuva_temporal.csv', index=False)

O QUE SERÁ PRECISO FAZER NO GAMA

🎮 GAMA: O que vai fazer (simulação)
Estrutura dos arquivos GAML:
text
models/
├── MAIN.gaml
├── HIDROLOGIA.gaml
├── TERRACEAMENTO.gaml
└── DANOS.gaml
1. MAIN.gaml - Arquivo principal:
gaml
model inundacao_rs

import "HIDROLOGIA.gaml"
import "TERRACEAMENTO.gaml" 
import "DANOS.gaml"

global {
    // --- Variáveis carregadas do Python ---
    // Arquivos CSV gerados pelo Python
    file arquivo_celulas <- file("../data/SAIDA/celulas_terreno.csv");
    file arquivo_chuva <- file("../data/SAIDA/chuva_temporal.csv");
    file arquivo_rio <- file("../data/SAIDA/parametros_rio.csv");
    
    // --- Variáveis de simulação ---
    float tempo_atual min <- 0.0;
    float intensidade_chuva mm_h <- 0.0;
    bool transbordamento_rio <- false;
    
    init {
        // Carregar dados processados pelo Python
        create carregar_celulas from: arquivo_celulas;
        create carregar_chuva from: arquivo_chuva;
        
        // Criar agente rio
        create Rio with: [parametros: read(arquivo_rio)];
    }
}

experiment simulacao_rs type: gui {
    // Configuração visual
    output {
        display mapa_inundacao {
            graphics "Terreno" {
                loop cell over: CelulaTerreno {
                    color: cell.profundidade_agua > 0.0 ? #blue : #green;
                }
            }
        }
    }
}
2. HIDROLOGIA.gaml - Lógica hidrológica:
gaml
agent CelulaTerreno {
    // --- Atributos do Python ---
    float elevacao;          // do CSV
    float resistencia_solo;  // do CSV  
    bool tem_terraço;        // do CSV
    string cultura;          // do CSV
    
    // --- Variáveis dinâmicas ---
    float profundidade_agua <- 0.0;
    float agua_infiltrada <- 0.0;
    float escoamento_superficial <- 0.0;
    
    // --- Comportamentos ---
    reflex aplicar_chuva {
        float precip <- global.intensidade_chuva * (5.0 / 60.0); // mm em 5 min
        float infiltracao <- min(precip, resistencia_solo * 0.02);
        float excesso <- max(0.0, precip - infiltracao);
        
        agua_infiltrada <- agua_infiltrada + infiltracao;
        profundidade_agua <- profundidade_agua + excesso;
    }
    
    reflex propagar_agua {
        if (profundidade_agua > 0.01) {
            // Lógica de propagação com terraceamento
            list<CelulaTerreno> vizinhas <- self neighbors_at(10.0);
            list<CelulaTerreno> alvos <- vizinhas where (each.elevacao < self.elevacao);
            
            if (!empty(alvos)) {
                if (tem_terraço) {
                    // Com terraceamento: direcionar fluxo
                    propagar_com_terraço(alvos);
                } else {
                    // Sem terraceamento: fluxo natural
                    propagar_sem_terraço(alvos);
                }
            }
        }
    }
}
3. TERRACEAMENTO.gaml - Lógica dos terraços:
gaml
action propagar_com_terraço(list<CelulaTerreno> alvos) {
    // Encontrar direção do terraço
    CelulaTerreno alvo <- alvos first_with (each.elevacao == min(alvos collect each.elevacao));
    
    if (alvo != nil) {
        float volume_transferir <- profundidade_agua * 0.7;
        alvo.profundidade_agua <- alvo.profundidade_agua + volume_transferir;
        profundidade_agua <- profundidade_agua - volume_transferir;
    }
}



_________________________________________________________-

🔄 Fluxo de Trabalho Completo:
Fase 1: Python (Pré-processamento)
bash
# Executar scripts Python
cd projeto_rs/
python pre_processamento.py
python gerar_entradas_gama.py

# Isso gera:
# - data/SAIDA/celulas_terreno.csv
# - data/SAIDA/chuva_temporal.csv  
# - data/SAIDA/declividade.tif
# - data/SAIDA/resistencia_solo.tif
Fase 2: GAMA (Simulação)
gaml
// O GAMA carrega os arquivos gerados pelo Python
init {
    create CelulaTerreno from: "../data/SAIDA/celulas_terreno.csv";
    create SerieChuva from: "../data/SAIDA/chuva_temporal.csv";
}
Fase 3: Análise (Python pós-simulação)
python
# Ler resultados do GAMA
resultados = pd.read_csv('data/SAIDA/resultados_simulacao.csv')

# Gerar gráficos e análises
gerar_relatorio_agricultor(resultados)

🎯 Para que você usaria o HEC-HMS:
1. 🔍 Análise Hidrológica da Bacia (ANTES de rodar no GAMA)
    • Calcular vazões de pico nos rios que cortam as propriedades
    • Estimar volume total de escoamento para chuvas extremas
    • Obter hidrogramas (variação da vazão no tempo) para alimentar seu modelo GAMA
2. 📊 Gerar Dados de Entrada para o GAMA
O HEC-HMS calcularia:
python
# Entradas que o HEC-HMS geraria para seu modelo GAMA:
- Vazão_máxima_rio = 85.6  # m³/s (para o evento de 100 anos)
- Volume_total_escoamento = 125000  # m³
- Tempo_pico = 45  # minutos após início da chuva
- Hidrograma = [0, 12, 45, 85.6, 72, 35, ...]  # série temporal
3. 🌊 Validar seus Resultados do GAMA
    • Comparar se o volume de água que seu modelo GAMA simula é consistente com o cálculo hidrológico "padrão" do HEC-HMS
    • Verificar se os tempos de concentração estão razoáveis
🔄 Fluxo de Trabalho Integrado:
text
HEC-HMS (Cálculo hidrológico) → GAMA (Simulação espacial detalhada)
      |                              |
      ↓                              ↓
  Vazões do rio                Inundação nas
  Volume escoamento            propriedades
                               Danos agrícolas
📋 Exemplo Prático para seu Projeto:
No HEC-HMS você faria:
    1. Modelaria a bacia hidrográfica completa do rio que afeta as propriedades
    2. Simularia a chuva extrema do evento de maio/2024
    3. Obteria a vazão de pico que chega na área das propriedades
No GAMA você usaria esses dados para:
gaml
// Usar os resultados do HEC-HMS no seu modelo
global {
    float vazao_pico_hec <- 85.6; // m³/s (do HEC-HMS)
    float volume_total_hec <- 125000; // m³ (do HEC-HMS)
    
    // Comparar com seus resultados
    if (abs(volume_total_simulado - volume_total_hec) > 20%) {
        println "AVISO: Diferença significativa com HEC-HMS!";
    }
}

